## Rust学习之二--变量

---
在第一篇入门的笔记中我们能够通过demo对Rust这门语言有了一个大体的认知，那么接下来就要真正的从这门语言的各种语法及特性入手来进行系统性的学习。那么话不多说，让我们来看看今天的主角--Rust的变量。

---
#### （一）变量的定义
在Rust这门语言中，变量主要有两种定义方式，在Rust中也有两个相应的关键字与其对照，它们分别是“let”以及“const”关键字。相信有过其他语言基础的小伙伴肯定一下就猜出“let”是定义一般变量的，而“const”是定义常量的，是这样没错，那么接下来我们就来详细的看看这两个关键字吧！
1. let：上面我们有提到，一般的变量定义我们都会使用这个关键字来进行定义，但是首先我们要清楚一个Rust语言的一个特性：那就是变量也是分为可变（immutable）与不可变的（unimmutable）当我们使用let直接去定义一个变量时，默认该变量是不可变的。

   ```
   let x = 1; //此时该变量不可变
   ```
   如果我们尝试修改上面变量的话，会出现下面的报错:
   ```
   let x = 1;
   x = 2;
   cannot assign twice to immutable variable
   ```
   看到这里可能很多小伙伴会产生疑惑，如果变量不可变的话那么我们以后不是要定义一大堆冗余的变量吗？别忘了上面我们提到的，Rust是支持可变变量的定义的。
   ```
   let mut x = 1; //关键就在这里，加上mut关键字后则为可变变量
   ```
   看到这里是不是觉得浑身舒畅了呢？此时如果你去重复上面重新赋值的操作的话，Rust的编译器就不会报错了，同时值也能够被重新绑定到变量“x”上。
   
2. const：接下来让我们来看看Rust中常量是如何定义的。既然是常量，那么我们肯定期望它在任何时候都是确定的，不论从数据类型或者是它的值来看，我们都希望在去访问它的时候它能给我们一个明确的“答复”。Rust就是这么做的，当我们使用“const”关键字去定义一个常量的时候，需要显式的指定这个常量的数据类型，同时这个常量的值要是确定的（比如固定值或者是常量表达式），不能用任何函数调用来为它赋值。（======值得注意的是====，常量可以定义在任何作用域，包括全局作用域，关于作用域的说明，后续的文章中会逐步向大家揭开==）

   ```
   const CONSTANT:u32 = 100; //这里我们为常量指定了确定的值和数据类型，而const默认即是不可变
   ```
 
#### （二）变量的隐藏  
以上两个关键字已经介绍完了，接下来我们继续来看Rust语言中另一个有意思的特性，那就是隐藏变量（Shadowing），Rust语言允许我们在同一个作用域下定义同名变量，而此时原来的变量就会被新的同名变量隐藏掉，如同以下写法：
```
let x = 1;
let x = x + 1; //和 x = x + 1有本质不同
println!("x is: {}", x);

x is: 2
```
我们能够清楚的看到变量“x”在上述代码中被定义了两次。什么？你说这和上面我们学习的不一样？可能有小伙伴会产生疑问，let定义的变量默认不是不可变的吗？这里我们要睁大眼睛好好看看，对第二个“x”操作的时候我们也加了“let”，这等于重新定义了一个名为“x”的变量，而旧的“x”在计算完成后就结束了自己的生命了。  
通过这个特点，我们甚至可以“改变”变量的数据类型，请注意这里的改变我加了双引号，当我们重新定义一个变量的时候实际上是与旧的同名变量使用了不用的内存空间的，他们只是取了相同的名字，本质上并没有什么关联。而当我们想要去尝试修改可变变量的数据类型时则会产生以下的情况：
```
let x = "1";
let x = 1; //正常运行不会报错

let x = "1";
x = 1; //会报：expected &str, found usize的错
```